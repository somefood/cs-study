# 5장 응집도 : 흩어져 있는 것들

응집도란 모듈 내부에 있는 `데이터와 로직 사이의 관계`가 얼마나 강한지 나타내는 지표이다.

### 5.1 static 메서드 오용

``` java
class OrderManager{
static int add(int moneyAmount1, int moneyAmount2){
  retrun moneyAmoun1+moneyAmount2;
}
}

// 데이터 클래스와 static 메서드를 함께 사용하는 상황 -> 데이터와 로직이 분리!
moneyData1.amount = OrderManager.add(moneyData1.amount,moneyData2.amount);

```

#### 5.1.1 ~ 5.1.3 static 메서드에서 데이터를 활용하는 방법

- staic 메서드는 인스턴스 변수를 사용할 수 없다.
- staic 메서드가 인스턴스 변수를 사용하는 구조로 변경하는 것이 응집도 측면에서 올바르다.
```java

class OrderManager{
 private int moneyAmount1;
 private int moneyAmount2;

static int add(int moneyAmount1, int moneyAmount2){
  retrun moneyAmoun1+moneyAmount2;
  }
}
```
- 인스턴스 메서드이지만, 인스턴스 변수를 활용하지 않는 메서드는 수정하는 것이 좋다.

  #### 5.1.4 ~ 5.1.5 static 메서드를 활용하는 이유와 상황

  - 데이터와 로직을 분리하여, 인스턴스 생성없이 편리하게 활용할 수 있다.(절자치향적)
  - 범용적인(전체 인스턴스에서 사용)되는 상황에 적합하다.
 
### 5.2 초기화 로직 분산

```
public class GiftPoint {
    private static final int MIN_POINT = 0;
    final int value;

    public GiftPoint(final int point) {
        if (point < MIN_POINT) {
            throw new IllegalArgumentException("포인트를 0 이상 입력해야 합니다.");
        }
        this.value = point;
    }
    
    GiftPoint add(final GiftPoint other) {
        return new GiftPoint(value + other.value);
    }
    
    boolean isEnough(final ConsumptionPoint point) {
        return point.value <= value;
    }
    
    GiftPoint consume(final ConsumptionPoint point) {
        if (!isEnough(point)) {
            throw new IllegalArgumentException("포인트가 부족합니다.");
        }
        return new GiftPoint(value - point.value);
    }
}
```

- 초기화를 다양한 상황에서 구현하게 된다. 
```
GiftPoint 표준회원포인트 = new GiftPoint(3000);
GiftPoint 프리미엄회원포인트 = new GiftPoint(5000);
```

#### 5.2.1 private 생성자 + 팩토리 메서드를 사용한 초기화

```
class GiftPoint {
	private static final MIN_POINT = 0;
	private static fianl STANDARD_MEMBERSHIP_POINT = 3000;
	private static fianl PREMIUM_MEMBERSHIP_POINT = 10000;
	final int value;

	private GiftPoint(fianl int point) {
		if(point < GiftPoint.MIN_POINT) throw new Error("포인트를 0 이상 입력해야 합니다.");
		this.value = point;
	}
	
	static GiftPoint forStandardMembership() {
		return new GiftPoint(GiftPoint.STANDARD_MEMBERSHIP_POINT);
	}

	static GiftPoint forPremiumMembership() {
		return new GiftPoint(GiftPoint.PREMIUM_MEMBERSHIP_POINT);
	}

	// ...
}
// 초기화가 팩토리 메서드를 통해 이루어진다. 즉 GiftPoint에 응집된다.
GiftPoint 표준회원포인트 = GiftPoint.forStanadardMembership();
GiftPoint 프리미엄회원포인트 = GiftPoint.forPremiumdMembership();
// 
```

### 5.3 범용 처리 클래스 - 언제 범용적인 클래스를 생성해야하는 지 고민이 필요하다. 예) 로그, 트랜잭션..


### 5.4 결과를 리턴하는 데 매개변수 사용하지 않기

``` java

// 매개 변수 값이 변경된다. -> 출력 매개 변수
class ActorManager {
	shift(location Location, int shiftX, int shiftY) {
		location.x += shiftX;
		location.y += shiftY;
	}
}

```
- 데이터(매개변수)와 로직(ActorManager)가 분리되어 있기 때문에 악마가 발생할 수 있다.

```
class Location {
 final int x;
 fianl int y;

	Location (fianl int x, final int y) {
		this.x = x;
		this.y = y;
	}

	Location shift(final int shiftX, final int shiftY) {
		final int nextX = x + shiftX;
		final int nextY = y + shiftY;

		return new Location(nextX, nextY);
	}
}

```

### 5.5 매개변수가 너무 많은 경우

- 매개 변수가 많아 진다는 것은 많은 기능이 포함된다는 의미이다.
- 많은 기능이 한번에 포함되면 버그, 코드 이해 시간이 증가한다.
- 기본 자료형에 집착하지 말고, 의미 있는 단위는 클래스를 활용해서 설계하는 것이 좋다.

### 5.6 메서드 체인

- 메서드를 활용하기 위해서는 체인에 대한 이해가 필요하다.
- 메서드를 사용하는 쪽에서는 메서드에 대한 정보없이 사용할 수 있는 것이 좋다.(데메테르의 법칙)
- 호출하는 쪽이 아니라, 호출 되는 쪽에서 로직을 구현하는 것이 좋다.
