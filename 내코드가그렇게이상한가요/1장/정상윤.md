# 1장. 잘못된 구조의 문제 깨닫기

나쁜 구조로부터, 좋은 구조를 이해할 수 있다.

나쁜 구조는 코드를 읽고 이해하는 데 오래 걸리고, 버그가 계속해서 발생하고, 나쁜 구조를 양산한다.

### 1.1 의미를 알 수 없는 이름

코드 1.1 기술 중심 명명
```java
class MemoryStateManager{
    void changeIntValue01(int changeValue) {
        intValue01 -= changeValue;
        if (intValue01 < 0) {
            intValue01 = 0;
            updateState02Flag();
        }
    }
}
```
코드 1.1 일련번호 명명
```java
void method001();
void method002();
void method003();
```

#### 기술 중심, 일련번호 명명 모두 코드에서 의도를 읽어 낼 수 없다. 따라서 코드를 읽으면서 이해하기 어렵다.

### 1.2 이해하기 어렵게 만드는 조건 분기 중첩

- If 조건의 중첩은 가독성을 떨어트린다.


### 1.3 수 많은 악마를 만들어 내는 데이터 클래스

코드 1.5 데이터밖에 없는 클래스 구조
```java
import java.math.BigDecimal;

public class ContractAmount {

    public int amountIncludingTax;
    public BigDecimal salesTaxRate;
    
}
```

- 데이터를 갖고 있기만 하는 클래스를 데이터 클래스라고 부른다.
- 데이터의 연산이 데이터 클래스 이외의 클래스에서 구현된다면, 실수할 가능성이 높아진다.


코드 1.6 ContractManager에 작성된 금액 계산 로직

```java
import java.math.BigDecimal;

public class ContractManager {
    public ContractAmount contractAmount;

    //세금 포함 금액 계산
    public int calculateAmountIncludingTax(int amountExcludingTax
                                    , BigDecimal salesTaxRate) {

        BigDecimal multiplier = salesTaxRate.add(new BigDecimal("1.0"));
        BigDecimal amountIncludingTax =
                multiplier.multiply(amountExcludingTax);
        return amountIncludingTax.intValue();
    }

    //계약 체결
    public void conclude() {
        // 생략
        int amountIncludingTax =
                calculateAmountIncludingTax(amountExcludingTax, salesTaxRate);
        
        contractAmount = new ContractManager();

        contractAmount.amountIncludingTax = amountIncludingTax;
        contractAmount.salesTaxRate = salesTaxRate;
        // 생략
    }
}
```

#### 1.3.1 사양을 변경할 때 송곳니를 드러내는 악마

소비세와 관련된 변경이 발생한 상황

1. `데이터`와 `데이터를 계산하는 로직`이 분리되어 있으므로, 계산이 필요할 때 마다 변경해주어야 한다.
2.  따라서, 변경이 발생하면 모든 코드를 변경해주어야 한다.
3.  즉, 데이터와 로직이 결합된 `응집도 높은 구조`를 가져야 한다.

#### 1.3.2 코드 중복

- 관련 코드가 떨어져 있으면, 관련된 것끼리 묶어서 파악하기 힘들다.

#### 1.3.3 수정 누락

- 변경이 발생하면, 중복된 코드를 모두 고쳐야 하기에 실수할 수 있다.

#### 1.3.4 가독성 저하

- 중복된 코드를 모두 찾으면서 이해해야 하므로, 가독성이 떨어진다.

#### 1.3.5 초기화되지 않은 상태(쓰레기 객체)

- 데이터 객체 내부에 어떤 타입 (Primitive 혹은 Reference Type) 존재하는 지 알 수 없다. 

#### 1.3.6 잘못된 값 할당

- Validation 매번 구현해야 한다.

### 1.4 악마 퇴치의 기본

1. 나쁜 구조가 나쁘다는 것을 인식해야 한다.
2. 좋은 설계 (예: 객체 지향 설계)


# 2장 설계 첫걸음

### 2.1 의도를 분명히 전달할 수 있는 이름 설계

코드 2.1 어떤 일을 하는지 이해하기 힘든 로직

``` java
int d = 0;
d = p1 + p2;
d = d - ((d1+d2)/2)

if(d < 0){
    d = 0;
}
```

- 이름을 짧게 줄이면, 타자 수는 줄지만 나중에 이해하기가 힘들다.

코드 2.2 의도를 알 수 있는 이름 붙이기
``` java

int damageAmount = 0;
damageAmount = playerArmPower + playerWeaponPower; // 1
damageAmount = damageAmount - ((enemyBodyDefence + enemyArmorDefence) / 2); // 2 

if (damageAmount < 0){
    damageAmount = 0;
}

```

### 2.2 목적별로 변수를 따로 만들어 사용하기

- 같은 변수에 값을 다시 할당하는 것 : `재할당`

``` java

int totalPlayerAttackPower = playerArmPower + playerWeaponPower;
int totalEnemyDefence = enemyBodyDefence + enemyArmorDefence;

int damageAmount = totalPlayerAttackPower - (totalEnemyDefence / 2);
if ( damageAmount < 0){
    damageAmount = 0;
}

```

### 2.3 단순 나열이 아니라, 의미 있는 것을 모아 메서드로 만들기

- 단순 나열되어 있으면, 로직의 시작 끝 그리고 역할을 이해하기 힘들다.
- 예방을 위해서는 의미 있는 로직을 모아서 메서드로 구현하는 것이 좋다.

코드 2.4 의미를 알기 쉽게 메서드로 만들기

``` java

//플레이어 공격력 합계 계산

int sumUpPlayerAttackPower(int playerArmPower, int playerWeaponPower){

    return playerArmPower + playerWeaponPower;
}

// 적의 방어력 계산 합계

int sumUpEnemyDefence(int enemyBodyDefence, int enemyArmorDefence){
    return enemyBodyDefence + enemyArmorDefence;
}

// 데미지 평가
int estimateDamage(int totalPlayerAttackPower, int totalEnemyDefence){
    int damageAmount = totalPlyerAttackPower - (totalEnemyDefence/2);
    if(damageAmount < 0 ){
        retrun 0;
    }
    
    return damageAmount;
}

```


```java

int totalPlayerAttackPower = sumUpPlayerAttackPower(playerBodyPower, playerWeaponPower)
int totalEnemyDefence = sumUpEnemyDefence(enemyBodyDefence, enemyArmorDefence)
int damageAmount = estimateDamage(totalPlayerAttackPower, totalEnemyDefence)

```

### 2.4 관련된 데이터와 로직을 클래스로 모으기

- 변수를 지역 변수로 관리하게 되면 변경 요인에 따라 지속적으로 변경해주어야 한다.
- 또한 예외 상황에 따른 코드를 매번 구현해주어야 하므로, 실수하기 쉽다.
- 이러한 문제를 해결해주는 것이 클래스

```java
class HitPoint{
    
    private static final int MIN = 0;
    private static final int MAX = 999;
    final int value;


    HitPoint(final int value) {
        if(value < MIN) throw new IllegalArgumentException(MIN +"이상을 지정해 주세요.");
        if(value > MAX) throw new IllegalArgumentException(MIN +"이하를 지정해 주세요.");

        this.value = value;
    }

    // 대미지를 받음.
    HitPoint damage(final int damageAmount) {
        final int damaged = value - damageAmount;
        final int corrected = damaged < MIN ? MIN : damaged;
        return new HitPoint(corrected);
    }

    //회복
    HitPoint recover(final int recoveryAmount) {
        final int recovered = value + recoveryAmount;
        final int corrected = MAX < recoverd ? MAX : recovered;
        return new HitPoint(corrected);
    }
    
}
```

- 클래스 내부에 계산 하는 로직이 응집되어 있다.
- 데이터의 값을 검증하는 로직이 생성자에 선언되어 있다. -> 오류를 예방하고, 한 곳에서 관리할 수 있다.
- 이에 따라 유지 보수가 쉬워진다.