# 8장 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조

- 결합도: 모듈 사이의 의존도를 나타내는 지표. (여기서는 클래스)
- 클래스끼리 많이 의존하고 있으면 강한 결합(tightly coupling)이라 하고 반대는 느슨한 결합(loose coupling)이라 한다.
- 느슨한 결합 구조가 되어야 코드 변경이 쉬워짐
- 강한 결합 문제의 원인은 책무의 분리 인데, 책무를 제대로 생각하지 않으면 결합도가 높아지게 된다
> 책무: 책임과 의무, 즉 의무를 다 해야 하는 책임
> 소프트웨어에서 책무는 어떤 관심사가 정상적으로 작동하게 제어야 하는 책임

## 8.1 결합도와 책무

## 8.2 다양한 강한 결합 사례와 대처 방법

### 8.2.1 상속과 관련된 강한 결합

### 8.2.2 인스턴스 변수별로 클래스 분할이 가능한 로직

```java
class Util {
    private int reservationId;
    private ViewSettings viewSettings;
    private MailMagazine mailMagazine;
    
    void cancelReservation() {}
    
    void darkMode() {}
    
    void beginSendMail() {}
}
```

- 위 세 개는 서로 다른 책임을 가졌는데, Util 클래스라는 한 곳에 정의되어 있음
- 서로 연관된 변수와 메서드를 묶어 하나의 클래스로 모아주는 것이 필요함

### 8.2.3 특별한 이유 없이 public 사용하지 않기

- 

### 8.2.4 private 메서드가 너무 많다는 것은 책임이 너무 많다는 것

- Order 클래스에서 가격 할인과 최근 본 상품 리스트 확인 등을 한다면 엄연히 다른 책임을 가진 둘이 존재하는 것임
- 이렇게 되면 private 메서드가 많아지게 되고, 이는 많은 책임을 가지고 있음을 알리는 것임
- 책임이 다른 메서드는 다른 클래스로 분리해야함

### 8.2.5 높은 응집도를 오해해서 생기는 강한 결합

### 8.2.6 스마트 UI

- 화면 표시를 담당하는 클래스에서 화면 표시와 직접적인 관련이 없는 책무가 구현되어 있는 클래스를 `스마트UI`라 함
- 복잡한 금액 계산 로직을 프런트에서 구현하게 되면 디자인 변경 시 버그가 발생하기 쉬움
- UI는 보여주는 것에 집중하고, 계산을 담당하는 책무를 가진 객체를 분리해줘야 함

### 8.2.7 거대 데이터 클래스

```java
public class Order {
    public int orderId;
    public int customerId;
    public List<Product> products;
    public ZonedDateTime orderTime;
    public OrderState orderState;
    public int reservationId;
    // 기타 등등 인스턴스 변수
}
```

- 위와 같이 Order에 모든 데이터를 다 집어넣게 되면 해당 클래스는 점점 거대해지고 관리하기 어려워짐
- 온라인 쇼핑몰은 발주, 예약, 배송 등 다양한 유스케이스 존재
- 각각 유스케이스에서 필요한 데이터만 접근하고 사용할 수 있게 해줘야 함

### 8.2.8 트랜잭션 스크립트 패턴

- 메서드 내부에 일련의 처리가 하나하나 길게 작성되어 있는 구조를 `트랜잭션 스크립트 패턴(Transaction Script Pattern)`이라 한다. (절차적 프로그래밍이라고도 함)
- 데이터를 보유하고 있는 클래스(데이터 클래스)와 데이터를 처리하는 클래스를 나누어 구현할 때 자주 발생함
- 이를 남용하면 메서드 하나가 수백 줄의 거대한 로직이 되기에 지양해야 함

### 8.2.9 갓 클래스 (GOD CLASS)

- 하나의 클래스 내부에 수천에서 수만 줄의 로직을 담고 있으며, 수많은 책임을 담당하는 로직이 난잡하게 섞여 있는 클래스
- 어떤 로직과 관련이 있는지, 책무를 파악하기 굉장히 힘듦
- 기능을 수정하려면, 영향 범위를 파악하기 위해 많은 코드를 살펴봐야 함

### 8.2.10 강한 결합 클래스 대처 방법

- 객체 지향 설계와 단일 책임 원칙에 따라 설계해야 함
- 거대한 강한 결합 클래스는 책임별로 클래스를 분할해야 함
- 단일 책임 원칙에 따라 설계된 클래스는 보통 100~200줄 이내로 끝남
