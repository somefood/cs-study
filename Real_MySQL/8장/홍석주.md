# 인덱스

- 데이터베이스 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건
- 순차 I/O, 랜덤 I/O 중 순차 I/O가 성능이 더 잘나온다. 하지만 랜덤 I/O로 조회되는 경우가 더 많기에 MySQL에선 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능을 활용한다.
- 어찌됐건 쿼리를 튜닝한다는 것은 랜덤 I/O 자체를 줄여주는 작업이라 보면 된다.
- 인덱스 레인지 스캔은 랜덤 I/O를 풀 테이블 스캔은 순차 I/O를 사용

## 인덱스란

- 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key - value pair)으로 구성
- 정렬이 항상 되어 있어야 한다.
- SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과가 날 수 있다.
- 인덱스(키)의 종류는 다음과 같이 분류할 수 있음
  - 프라이머리 키: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스. 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 식별자라고도 부름 NULL 값을 ㅎ용하지 않으며 중복을 허용하지 않음
  - 세컨더리 인덱스: 프라이머리 키 제외한 나머지. 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수 있어 대체키라고도 부름
- 데이터 저장 방식(알고리즘) 별로 구분
  - B-Tree 인덱스: 가장 일반적으로 사용. 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱함
  - Hash 인덱스: 해시값을 계산해서 인덱싱하는 알고리즘. 매우 빠른 검색 지원. 값은 변경해서 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 이 인덱스를 사용할 수 없음. 메모리 기반의 데이터베이스에서 많이 사용 (Redis)

## B-Tree 인덱스

- 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘. 여전히 가장 범용적으로 사용된다.
- Binary(이진)의 B가 아니라 Balanced의 B이다.
- 칼럼의 원래 값을 변형시키지 않음 (앞부분을 잘라 관리하긴 함)
- 인덱스 구조체 내에서 `항상 정렬`된 상태를 유지
- 구조는 다음과 같음
  - 루트 노드(Root node): 최상위에 하나가 존재하고 아래에 자식 노드가 붙어 있음
  - 브랜치 노드(Branch node): 중간에 위치한 브랜치
  - 리프 노드(Leaf node): 가장 하위에 위치한 노드
- 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되며, 인덱스의 리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있음
- InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다.
  - 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
  - InnoDB는 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한 번 검색한다.

### 인덱스 키 추가

- 새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 않을 수도 있다.
- B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절할 위치를 검색
- 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프노드에 저장한다.
- 리프노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리돼야 하며, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 이런 작업으로 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려짐

### 인덱스 키 삭제

- 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업 완료
- 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있음.
- 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하여 디스크 I/O가 필요함
- MySQL 5.5이상 버전에선 버퍼링되어 지연 처리될 수 있음
- 처리가 지연된 인덱스 키 삭제 또한 사용자에게 특별한 악영향 없이 내부적으로 처리하므로 걱정할 필요 없다.

### 인덱스 키 변경

- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경하는 것은 불가능함
- B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
- 즉, 삭제와 추가 작업이 절차대로 진행

### 인덱스 키 검색

- INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구착하는 이유는 바로 `빠른 검색` 때문
- 인덱스를 검색하는 작업은 루트 노드부터 브랜치, 리프 노드까지 이동하면서 비교작업을 수행하며 이를 `트리 탐색`이라고 함
- SELECT 뿐만 아니라 UPDATE, DELETE 처리할 때도 사용됨
- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우에 사용할 수 있음
- 부등호 (<, >) 비교 조건에서도 활용할 순 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용할 수 없음.
- 또한 인덱스의 키 값에 변형이 가해진 후 비교되는 경우에도 B-Tree의 인덱스를 절대 탈 수 없음 -> 이미 변형된 값은 B-Tree 인덱스에 존재하는 것이 아니기 때문
  - 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업에서 사용 어려우니 이 점 주의
- InnoDB 스토리지 엔진에서 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있음
- UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 심지어 테이블의 모든 레코드를 잠글 수 있다.

> 인덱스 설계가 많이 중요하고 많은 부분에 영향을 미침!!