# 옵티마이저와 힌트

## 9.1

> 어떤 DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분. 하지만 실행 계획을 잘 이해해야 최적화를 잘 할 수 있기에 잘 이해하는 것이 필요

### 9.1.1 쿼리 실행 절차

MYSQL 서버에서 쿼리 실행 과정은 크게 아래와 같음

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)
   - SQL 파싱(Parsing), SQL 파서라는 모듈이 처리. 문법이 잘못되면 여기서 걸러짐
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택 -> 실행 계획 생성
   - 불필요한 조건 제거 및 복잡한 연산의 단순화
   - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
   - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
   - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
   - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업 수행


### 9.1.2 옵티마이저 종류

- 옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당하며 `비용 기반 최적화(Cost-base Optimizer, CBO)`와 초기 오라클 DBMS 사용된 `규칙 기반 최적화(Rule-based optimizer, RBO)`가 있다.
- 규칙 기반은 내장된 우선 순위에 따라 실행 계획을 수립하는 방식인데, 요즘 거의 사용 안 한다 (패스)
- 비용 기반 최적화는 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다. 이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식으로 쿼리를 최종적으로 사용한다.

## 9.2 기본 데이터 처리

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

### 9.2.2 병렬 처리

### 9.2.3 ORDER BY 처리 (Using filesort)

### 9.2.4 GROUP BY 처리

### 9.2.5 DISTINCT 처리

- 특정 칼럼의 유니크 값만 조회하려면 SELECT에 DISTINCT를 사용함
- DISTINCT는 MIN(), MAX() 또는 COUNT() 같은 집합 함수와 함께 사용되는 경우와 집합 함수가 없는 경우에 영향을 미치는 범위가 바뀜
- 집합 함수와 같이 DISTINCT가 사용되는 쿼리의 실행 계획에는 DISTINCT 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요함. 하지만 실행 계획의 Extra 칼럼에선 `Using temporary` 메시지가 출력되진 않음

#### SELECT DISTINCT

- 단순 SELECT 되는 레코드에서 유니크한 레코드만 가져오려면 `SELECT DISTINCT` 형태의 쿼리를 사용하는데, 이러면 GROUP BY와 동일한 방식으로 처리됨. 8.0 버전부터는 GROUP BY를 수행하는 쿼리에 ORDER BY 절이 없으면 정렬을 사용하지 않기 때문에 아래 두 쿼리는 내부적으로 같은 작업 수행

```sql
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROM salaries GROUP BY emp_no;
```

#### 집합 함수와 함께 사용된 DISTINCT

### 9.2.6 내부 임시 테이블 활용

- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블(Internal temporary table)을 사용
  - `CREATE TEMPORARY TABLE` 명령으로 만든 임시 테이블관 다른 것
- 일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성되었다가 테이블의 크기가 커지면 디스크로 옮겨짐
  - 특정 예외 케이스에는 메모리를 거치지 않고 바로 디스크에 임시 테이블이 만들어지기도 함
- MySQL 엔진이 내부적인 가공을 위해 생성한 임시 테이블은 다른 세션이나 다른 쿼리에서 볼 수도 없고 사용할 수 없다.
- 사용자가 생성한 임시 테이블(CREATE TEMPORARY TABLE)과 달리 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제됨
- MySQL 8.0 이전엔 원본 테이블 스토리지 엔진과 상관없이 임시 테이블이 메모리면 MEMORY 스토리지, 디스크는 MyISAM 스토리지 엔진을 사용했는데 8.0버전부턴 메모리는 `TempTable`, 디스크는 `InnoDB` 스토리지 엔진을 사용토록 개선함

#### 임시 테이블이 필요한 쿼리

- 아래의 패턴들의 쿼리는 MySQL 엔진에서 별도의 데이터 가공 작업을 필요하므로 내부적으로 테이블을 생성하는 케이스이다.
또는 인덱스를 사용하지 못할 때는 내부 임시 테이블을 생성해얄 수도 있음
  1. ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
  2. ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
  3. DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
  4. UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 칼럼이 UNION RESULT 인 경우)
  5. 쿼리의 실행 계획에서 select_type이 DERIVED인 경우
- 확인 방법은 Extra 칼럼에 `Using temporary`가 있으면 임시 테이블을 사용하는 것 or 3, 4, 5번인 경우도 임시 테이블 사용
- 1~4 패턴의 경우 유니크 인덱스를 가지는 내부 임시 테이블이 만들어지고, 5번의 경우 유니크가 없는 내부 임시 테이블이 생성된다.
- 일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 그렇지 않은 쿼리보다 처리 성능이 상당히 느림 (왤까..)

#### 임시 테이블이 디스크에 생성되는 경우

- 내부 임시 테이블은 기본적으로 메모리상에 만들어지지만 아래와 같은 조건이면 메모리 임시 테이블을 사용하지 못 하고, 디스크 기반의 임시 테이블을 사용함
  1. UNION이나 UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512 바이트 이상인 크기의 칼럼이 있는 경우
  2. GROUP BY나 DISTINCT 칼럼에서 512 바이트 이상인 크기의 칼럼이 있는 경우
  3. 메모리 임시 테이블의 크기가 (MEMORY 스토리지 엔진에서) tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거가 (TempTable 스토리지 엔진에서) temptable_max_ram 시스템 변수 값보다 큰 경우

#### 임시 테이블 관련 상태 변수

- 실행 계획상에서 `Using temporary`가 표시되어도 이게 메모리에서 처리됐는지, 몇 개의 임시 테이블이 사용됐는지 알 수 없다.
- 임시 테이블이 디스큰지 메모린지 확인하려면 `SHOW SESSION STATUS LIKE 'Created_tmp%';`로 확인해 보면 됨
  - Created_tmp_tables: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값. 이 값은 내부 임시 테이블이 메모리인지 디스크로 만들어졌는지는 구분하지 않고 모두 누적함
  - Created_tmp_disk_tables: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태
  
```sql
FLUSH STATUS; -- 현재 세션의 상태 값 초기화
SHOW SESSION STATUS LIKE 'Created_tmp%';

+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Created_tmp_disk_tables | 0     |
| Created_tmp_files       | 5     |
| Created_tmp_tables      | 1     |
+-------------------------+-------+
```